<html>
<head>
<title>Práticas recomendadas em JS</title>
</head>

<body>
  <table>
  <thead>
    <tr>
      <td>Antigo</td>
      <td>Atual</td>
      <td>Quando</td>
      <td>Local de Uso</td>
      <td>Motivo Específico</td>
      <td>Quando Não Usar Nenhuma</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>==</td>
      <td>===</td>
      <td>Para comparações rigorosas em JavaScript</td>
      <td>Comparações rigorosas</td>
      <td>Evitar erros de tipo nas comparações em JavaScript</td>
      <td>Quando não há necessidade de comparações rigorosas</td>
    </tr>
    <tr>
      <td>alert()</td>
      <td>Custom modal dialogs</td>
      <td>Para melhorar a usabilidade e a experiência do usuário</td>
      <td>Mensagens e interações de usuário</td>
      <td>Melhorar a experiência do usuário com interfaces modernas</td>
      <td>Quando não há necessidade de mensagens ou interações de usuário</td>
    </tr>
    <tr>
      <td>arr.concat(arr2);</td>
      <td>const merged = [...arr, ...arr2];</td>
      <td>Para mesclar arrays</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de mesclar arrays</td>
    </tr>
    <tr>
      <td>arr.filter(Boolean);</td>
      <td>arr.filter(el =&gt; el);</td>
      <td>Para remover valores falsy de arrays</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de remover valores falsy</td>
    </tr>
    <tr>
      <td>arr.map(el =&gt; el * 2);</td>
      <td>arr.map(el =&gt; el * 2).filter(el =&gt; el &gt; 2);</td>
      <td>Para transformar e filtrar arrays</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de transformar e filtrar arrays</td>
    </tr>
    <tr>
      <td>arr[-1];</td>
      <td>arr.at(-1);</td>
      <td>Para acessar elementos de arrays com índices negativos</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de acessar elementos de arrays com índices negativos</td>
    </tr>
    <tr>
      <td>array.flat();</td>
      <td>const flatArray = array.flat();</td>
      <td>Para aplanar arrays aninhados</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de aplanar arrays</td>
    </tr>
    <tr>
      <td>array.flatMap(x =&gt; [x * 2]);</td>
      <td>const flatMappedArray = array.flatMap(x =&gt; [x, x * 2]);</td>
      <td>Para transformar e aplanar arrays</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de transformar e aplanar arrays</td>
    </tr>
    <tr>
      <td>Array.prototype.concat</td>
      <td>Spread operator (...)</td>
      <td>Para combinar arrays de forma mais eficiente e legível</td>
      <td>Combinar objetos e arrays</td>
      <td>Sintaxe mais concisa e legível para combinar objetos e arrays</td>
      <td>Quando não há necessidade de combinar arrays</td>
    </tr>
    <tr>
      <td>Array.prototype.findIndex</td>
      <td>Array.prototype.find</td>
      <td>Para encontrar o primeiro item que satisfaça uma condição de forma mais eficiente e legível</td>
      <td>Encontrar item em um array</td>
      <td>Forma mais eficiente e legível de encontrar o primeiro item que satisfaça uma condição</td>
      <td>Quando não há necessidade de encontrar itens em um array</td>
    </tr>
    <tr>
      <td>Array.prototype.map</td>
      <td>Array.from</td>
      <td>Para criar arrays a partir de objetos iteráveis ou pseudo-arrays</td>
      <td>Criação de arrays a partir de objetos iteráveis</td>
      <td>Melhor suporte a objetos pseudo-arrays e iteráveis</td>
      <td>Quando não há necessidade de criar arrays a partir de objetos iteráveis</td>
    </tr>
    <tr>
      <td>Array.prototype.reduce para somar valores</td>
      <td>Array.prototype.reduce com arrow function</td>
      <td>Para melhorar a clareza e concisão ao usar a função de redução</td>
      <td>Soma de valores em arrays</td>
      <td>Forma mais clara e concisa de usar a função de redução</td>
      <td>Quando não há necessidade de somar valores em arrays</td>
    </tr>
    <tr>
      <td>Array.prototype.splice para remover itens</td>
      <td>Array.prototype.filter</td>
      <td>Para remover itens de um array de forma mais clara e imutável</td>
      <td>Remover itens de um array</td>
      <td>Forma mais clara e imutável de remover itens de um array</td>
      <td>Quando não há necessidade de remover itens de um array</td>
    </tr>
    <tr>
      <td>Atomics.wait(typedArray, index, value);</td>
      <td>Atomics.waitSync(typedArray, index, value);</td>
      <td>Para operações de espera síncrona em ambientes de multithreading</td>
      <td>Sincronização de threads</td>
      <td>Melhor controle sobre a sincronização</td>
      <td>Quando não há necessidade de sincronização de threads</td>
    </tr>
    <tr>
      <td>Callback hell</td>
      <td>Promises ou async/await</td>
      <td>Para evitar aninhamento excessivo de callbacks e melhorar a legibilidade do código</td>
      <td>Operações assíncronas complexas</td>
      <td>Melhor legibilidade e manejo de fluxos assíncronos</td>
      <td>Quando não há operações assíncronas a serem realizadas</td>
    </tr>
    <tr>
      <td>Callbacks</td>
      <td>Promises ou async/await</td>
      <td>Para lidar com operações assíncronas de forma mais legível e gerenciável</td>
      <td>Operações assíncronas complexas</td>
      <td>Melhor legibilidade e manejo de fluxos assíncronos</td>
      <td>Quando não há operações assíncronas a serem realizadas</td>
    </tr>
    <tr>
      <td>class MyClass { constructor() { this.myField = 'value'; } }</td>
      <td>class MyClass { myField = 'value'; }</td>
      <td>Para definir campos de classe de forma mais concisa</td>
      <td>Declaração de classes</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de definir campos de classe</td>
    </tr>
    <tr>
      <td>class MyClass { constructor() { this.myField = 'value'; } }</td>
      <td>class MyClass { static myField = 'value'; }</td>
      <td>Para definir campos estáticos de classe</td>
      <td>Declaração de classes</td>
      <td>Melhor organização e acessibilidade de dados estáticos</td>
      <td>Quando não há necessidade de definir campos estáticos</td>
    </tr>
    <tr>
      <td>console.log</td>
      <td>Logging frameworks</td>
      <td>Para um logging mais robusto e gerenciável em produção</td>
      <td>Aplicações em produção</td>
      <td>Logging mais robusto e gerenciável</td>
      <td>Quando não há necessidade de logging em produção</td>
    </tr>
    <tr>
      <td>const arr = [1, 2, 3]; const newArr = arr.map(x =&gt; x * 2);</td>
      <td>const newArr = arr.flatMap(x =&gt; [x, x * 2]);</td>
      <td>Para manipular arrays de forma eficiente</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais eficiente e legível</td>
      <td>Quando não há necessidade de manipular arrays</td>
    </tr>
    <tr>
      <td>const arr = [1, 2, 3]; const newArr = arr.map(x =&gt; x * 2);</td>
      <td>const newArr = arr.flatMap(x =&gt; [x, x * 2]);</td>
      <td>Para transformar e aplanar arrays</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de transformar e aplanar arrays</td>
    </tr>
    <tr>
      <td>const bigInt = BigInt(1234567890);</td>
      <td>const bigInt = 1234567890n;</td>
      <td>Para criar BigInts</td>
      <td>Manipulação de números grandes</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de manipular números grandes</td>
    </tr>
    <tr>
      <td>const data = { name: 'Alice', age: 25 }; const name = data.name; const age = data.age;</td>
      <td>const { name, age } = data;</td>
      <td>Para extrair valores de objetos de forma concisa</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de extrair valores</td>
    </tr>
    <tr>
      <td>const entries = Object.keys(obj).map(key =&gt; [key, obj[key]]);</td>
      <td>const entries = Object.entries(obj);</td>
      <td>Para obter pares chave-valor de um objeto</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de obter pares chave-valor de objetos</td>
    </tr>
    <tr>
      <td>const global = Function('return this')();</td>
      <td>globalThis;</td>
      <td>Para acessar o objeto global</td>
      <td>Manipulação de escopo global</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de acessar o objeto global</td>
    </tr>
    <tr>
      <td>const merged = Object.assign({}, obj1, obj2);</td>
      <td>const merged = { ...obj1, ...obj2 };</td>
      <td>Para mesclar objetos</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de mesclar objetos</td>
    </tr>
    <tr>
      <td>const name = person.name; const age = person.age;</td>
      <td>const { name, age } = person;</td>
      <td>Para desestruturar objetos</td>
      <td>Desestruturação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de desestruturar objetos</td>
    </tr>
    <tr>
      <td>const newArr = []; arr.forEach(item =&gt; newArr.push(item * 2));</td>
      <td>const newArr = arr.map(item =&gt; item * 2);</td>
      <td>Para transformar elementos de um array</td>
      <td>Transformação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de transformar arrays</td>
    </tr>
    <tr>
      <td>const newObj = Object.assign({}, obj1, obj2);</td>
      <td>const newObj = { ...obj1, ...obj2 };</td>
      <td>Para clonar ou combinar objetos de forma eficiente</td>
      <td>Manipulação de objetos, especialmente em funções de utilidade</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de clonar ou combinar objetos</td>
    </tr>
    <tr>
      <td>const now = new Date();</td>
      <td>const now = Temporal.Now.plainDateTimeISO();</td>
      <td>Para manipulação moderna de datas e horas</td>
      <td>Manipulação de datas e horas</td>
      <td>API mais robusta e coerente</td>
      <td>Quando não há necessidade de manipulação de datas e horas</td>
    </tr>
    <tr>
      <td>const numbers = [1, 2, 3]; const reversed = numbers.reverse();</td>
      <td>const reversed = numbers.toReversed();</td>
      <td>Para reverter arrays sem modificar o original</td>
      <td>Manipulação de arrays</td>
      <td>Evitar mutação do array original</td>
      <td>Quando não há necessidade de reverter arrays</td>
    </tr>
    <tr>
      <td>const obj = Object.assign({}, a, b);</td>
      <td>const obj = { ...a, ...b };</td>
      <td>Para mesclar objetos</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de mesclar objetos</td>
    </tr>
    <tr>
      <td>const obj = { a: 1, b: 2 }; const copy = Object.assign({}, obj);</td>
      <td>const copy = { ...obj };</td>
      <td>Para copiar propriedades de objetos</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de copiar objetos</td>
    </tr>
    <tr>
      <td>const obj = {}; if (!obj.prop) { obj.prop = 'default'; }</td>
      <td>obj.prop</td>
      <td></td>
      <td>= 'default';</td>
      <td>Para atribuir valores padrão</td>
      <td>Atribuição de valores</td>
    </tr>
    <tr>
      <td>const obj = {}; if (obj.a) { obj.a(); }</td>
      <td>obj.a?.();</td>
      <td>Para evitar erros de acesso a propriedades</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e segura</td>
      <td>Quando não há necessidade de acessar propriedades</td>
    </tr>
    <tr>
      <td>const path = 'C:\\path\\to\\file';</td>
      <td>const path = String.rawC:\\path\\to\\file;</td>
      <td>Para evitar processamento de escape sequences</td>
      <td>Strings de caminho de arquivo, regex complexas</td>
      <td>Evita erros de escape e melhora a legibilidade</td>
      <td>Quando não há necessidade de strings não processadas</td>
    </tr>
    <tr>
      <td>const regex = /[a-zA-Z]/;</td>
      <td>const regex = /\p{L}/u;</td>
      <td>Para correspondência de caracteres com propriedades Unicode</td>
      <td>Manipulação de strings</td>
      <td>Aumenta a precisão na correspondência de padrões</td>
      <td>Quando não há necessidade de correspondência de padrões complexos</td>
    </tr>
    <tr>
      <td>const regex = new RegExp('pattern', 'flags');</td>
      <td>const regex = /pattern/flags;</td>
      <td>Para buscas avançadas em strings e correspondências complexas</td>
      <td>Processamento de strings, validação de entradas</td>
      <td>Poderoso e flexível para correspondência de padrões</td>
      <td>Quando simples correspondências de padrões são suficientes</td>
    </tr>
    <tr>
      <td>const response = await fetch(url); const data = await response.json();</td>
      <td>const data = await fetch(url).then(response =&gt; response.json());</td>
      <td>Para simplificar chamadas de API assíncronas</td>
      <td>Requisições HTTP assíncronas</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de fazer requisições HTTP</td>
    </tr>
    <tr>
      <td>const str = ' Hello World '; str.trim();</td>
      <td>str.trimStart(); str.trimEnd();</td>
      <td>Para remover espaços em branco do início e do fim de strings</td>
      <td>Manipulação de strings</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de remover espaços em branco</td>
    </tr>
    <tr>
      <td>const str = '\uD800'; const isWellFormed = /^[^\uD800-\uDFFF]$/u.test(str);</td>
      <td>const isWellFormed = str.isWellFormed();</td>
      <td>Para verificar se uma string está bem formada</td>
      <td>Manipulação de strings</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de verificar strings</td>
    </tr>
    <tr>
      <td>const str = 'abc'; const regex = /a/; const result = str.match(regex);</td>
      <td>const result = 'abc'.match(/a/);</td>
      <td>Para simplificar a busca de padrões em strings</td>
      <td>Manipulação de strings</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de buscar padrões</td>
    </tr>
    <tr>
      <td>const str = 'hello'; const chars = str.split('');</td>
      <td>const chars = [...str];</td>
      <td>Para dividir uma string em caracteres</td>
      <td>Manipulação de strings</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de dividir strings em caracteres</td>
    </tr>
    <tr>
      <td>const sym = Symbol('description');</td>
      <td>const sym = Symbol.for('description');</td>
      <td>Para compartilhar símbolos entre diferentes partes do código</td>
      <td>Manipulação de símbolos</td>
      <td>Reutilização de símbolos</td>
      <td>Quando não há necessidade de compartilhar símbolos</td>
    </tr>
    <tr>
      <td>const val = a</td>
      <td></td>
      <td>b;</td>
      <td>const val = a ?? b;</td>
      <td>Para atribuir valores padrão</td>
      <td>Atribuição de valores</td>
    </tr>
    <tr>
      <td>const value = (obj &amp;&amp; obj.value)</td>
      <td></td>
      <td>'default';</td>
      <td>const value = obj?.value ?? 'default';</td>
      <td>Para atribuir valores padrão de forma mais segura</td>
      <td>Atribuição de valores</td>
    </tr>
    <tr>
      <td>const values = Object.keys(obj).map(key =&gt; obj[key]);</td>
      <td>const values = Object.values(obj);</td>
      <td>Para obter valores de um objeto</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de obter valores de objetos</td>
    </tr>
    <tr>
      <td>const x = Math.max(a, b, c);</td>
      <td>const x = Math.max(...[a, b, c]);</td>
      <td>Para encontrar o valor máximo em um array</td>
      <td>Manipulação de arrays</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de encontrar o valor máximo</td>
    </tr>
    <tr>
      <td>document.body.scrollTop</td>
      <td>window.scrollY</td>
      <td>Para obter a posição de rolagem vertical de forma mais precisa e moderna</td>
      <td>Obter posição de rolagem vertical</td>
      <td>Forma mais precisa e moderna de obter a posição de rolagem vertical</td>
      <td>Quando não há necessidade de obter a posição de rolagem vertical</td>
    </tr>
    <tr>
      <td>document.cookie</td>
      <td>localStorage ou sessionStorage</td>
      <td>Para armazenar dados no cliente de forma mais segura e gerenciável</td>
      <td>Armazenamento de dados no cliente</td>
      <td>Armazenamento mais seguro e gerenciável de dados do cliente</td>
      <td>Quando não há necessidade de armazenar dados no cliente</td>
    </tr>
    <tr>
      <td>document.createElement e appendChild</td>
      <td>Element.insertAdjacentHTML</td>
      <td>Para inserir elementos HTML de forma mais direta e eficiente</td>
      <td>Inserção de HTML dinâmico</td>
      <td>Inserção mais eficiente e segura de conteúdo HTML</td>
      <td>Quando não há necessidade de inserir HTML dinamicamente</td>
    </tr>
    <tr>
      <td>document.createEvent</td>
      <td>new Event ou CustomEvent</td>
      <td>Para criar eventos personalizados de forma mais moderna e padronizada</td>
      <td>Criação de eventos personalizados</td>
      <td>Forma mais moderna e padronizada de criar eventos</td>
      <td>Quando não há necessidade de criar eventos personalizados</td>
    </tr>
    <tr>
      <td>document.execCommand('copy')</td>
      <td>navigator.clipboard.writeText</td>
      <td>Para copiar texto para a área de transferência de forma mais segura e moderna</td>
      <td>Copiar texto para a área de transferência</td>
      <td>Forma mais segura e moderna de copiar texto para a área de transferência</td>
      <td>Quando não há necessidade de copiar texto para a área de transferência</td>
    </tr>
    <tr>
      <td>document.forms['formName']</td>
      <td>document.querySelector('form[name="formName"]')</td>
      <td>Para selecionar formulários de forma mais moderna e flexível</td>
      <td>Seleção de formulários</td>
      <td>Seleção de formulários de forma mais moderna e flexível</td>
      <td>Quando não há necessidade de selecionar formulários</td>
    </tr>
    <tr>
      <td>document.getElementById</td>
      <td>document.querySelector</td>
      <td>Para selecionar elementos DOM com mais flexibilidade e consistência</td>
      <td>Seleção de elementos DOM</td>
      <td>Flexibilidade e consistência na seleção de elementos</td>
      <td>Quando não há necessidade de selecionar elementos DOM</td>
    </tr>
    <tr>
      <td>document.write</td>
      <td>DOM manipulation methods</td>
      <td>Para evitar práticas inseguras e obsoletas de manipulação do DOM</td>
      <td>Atualizações dinâmicas no DOM</td>
      <td>Evitar práticas obsoletas e inseguras como document.write</td>
      <td>Quando não há necessidade de manipular o DOM</td>
    </tr>
    <tr>
      <td>document.write('Hello World');</td>
      <td>document.getElementById('example').textContent = 'Hello World';</td>
      <td>Para evitar práticas inseguras e obsoletas de manipulação do DOM</td>
      <td>Atualizações dinâmicas no DOM</td>
      <td>Evitar práticas obsoletas e inseguras como document.write</td>
      <td>Quando não há necessidade de manipular o DOM</td>
    </tr>
    <tr>
      <td>element.attachEvent</td>
      <td>element.addEventListener</td>
      <td>Para adicionar eventos de forma mais padronizada e moderna</td>
      <td>Adicionar eventos</td>
      <td>Adição de eventos de forma padronizada e moderna</td>
      <td>Quando não há necessidade de adicionar eventos</td>
    </tr>
    <tr>
      <td>element.children</td>
      <td>element.childNodes</td>
      <td>Para obter todos os nós filhos, incluindo nós de texto e comentário</td>
      <td>Obter todos os nós filhos</td>
      <td>Forma mais abrangente de obter todos os nós filhos, incluindo nós de texto e comentário</td>
      <td>Quando não há necessidade de obter todos os nós filhos</td>
    </tr>
    <tr>
      <td>element.className = '...'</td>
      <td>element.classList.add/remove/toggle</td>
      <td>Para manipular classes de elementos de forma mais eficiente e flexível</td>
      <td>Manipulação de classes de elementos</td>
      <td>Sintaxe mais clara e eficiente para manipulação de classes</td>
      <td>Quando não há necessidade de manipular classes de elementos</td>
    </tr>
    <tr>
      <td>element.innerHTML += '...'</td>
      <td>element.insertAdjacentHTML</td>
      <td>Para adicionar HTML de forma mais eficiente e segura</td>
      <td>Adicionar HTML dinâmico</td>
      <td>Forma mais eficiente e segura de adicionar HTML ao DOM</td>
      <td>Quando não há necessidade de adicionar HTML dinamicamente</td>
    </tr>
    <tr>
      <td>Element.offsetTop e Element.offsetLeft</td>
      <td>Element.getBoundingClientRect()</td>
      <td>Para obter informações de posição e tamanho de elementos de forma mais precisa</td>
      <td>Obter informações de posição e tamanho de elementos</td>
      <td>Forma mais precisa e moderna de obter informações de posição e tamanho</td>
      <td>Quando não há necessidade de obter informações de posição e tamanho</td>
    </tr>
    <tr>
      <td>element.removeNode</td>
      <td>element.remove</td>
      <td>Para remover elementos do DOM de forma mais moderna e suportada</td>
      <td>Remover elementos do DOM</td>
      <td>Método moderno e suportado para remover elementos</td>
      <td>Quando não há necessidade de remover elementos do DOM</td>
    </tr>
    <tr>
      <td>element.scrollIntoView com opções padrão</td>
      <td>element.scrollIntoView({ behavior: 'smooth' })</td>
      <td>Para uma rolagem suave ao elemento</td>
      <td>Rolagem suave ao elemento</td>
      <td>Melhorar a experiência do usuário com rolagem suave</td>
      <td>Quando não há necessidade de rolar até um elemento</td>
    </tr>
    <tr>
      <td>element.setAttribute('style', '...')</td>
      <td>element.style.property = '...'</td>
      <td>Para manipular estilos inline de forma mais clara e controlada</td>
      <td>Manipulação de estilos inline</td>
      <td>Forma mais clara e controlada de manipular estilos</td>
      <td>Quando não há necessidade de manipular estilos</td>
    </tr>
    <tr>
      <td>element.setAttribute('style', 'color: red');</td>
      <td>element.style.color = 'red';</td>
      <td>Para manipular estilos inline de forma mais clara e controlada</td>
      <td>Manipulação de estilos inline</td>
      <td>Forma mais clara e controlada de manipular estilos</td>
      <td>Quando não há necessidade de manipular estilos</td>
    </tr>
    <tr>
      <td>eval()</td>
      <td>Secure parsing functions</td>
      <td>Para evitar vulnerabilidades de segurança</td>
      <td>Avaliação de código dinamicamente</td>
      <td>Evitar vulnerabilidades de segurança associadas ao uso de eval</td>
      <td>Quando não há necessidade de avaliação de código dinamicamente</td>
    </tr>
    <tr>
      <td>event.srcElement</td>
      <td>event.target</td>
      <td>Para acessar o elemento que disparou o evento de forma mais consistente</td>
      <td>Acesso ao elemento que disparou o evento</td>
      <td>Acesso consistente e confiável ao alvo do evento</td>
      <td>Quando não há eventos sendo disparados</td>
    </tr>
    <tr>
      <td>for (const value of asyncIterable) { await someFunction(value); }</td>
      <td>for await (const value of asyncIterable) { await someFunction(value); }</td>
      <td>Para iterar sobre dados assíncronos</td>
      <td>Funções assíncronas que processam listas de dados</td>
      <td>Simplifica o código e melhora a legibilidade ao lidar com promessas em loop</td>
      <td>Quando não há necessidade de iteração assíncrona</td>
    </tr>
    <tr>
      <td>for loops</td>
      <td>for...of ou forEach</td>
      <td>Para iterar sobre arrays de forma mais clara e moderna</td>
      <td>Iterações sobre arrays</td>
      <td>Sintaxe mais clara e moderna, melhorando a legibilidade</td>
      <td>Quando não há necessidade de iterar sobre arrays</td>
    </tr>
    <tr>
      <td>for...in</td>
      <td>Object.keys/values/entries</td>
      <td>Para iterar sobre as propriedades de objetos de forma mais segura</td>
      <td>Iterar sobre propriedades de objetos</td>
      <td>Iteração mais segura e controlada sobre propriedades de objetos</td>
      <td>Quando não há necessidade de iterar sobre as propriedades de objetos</td>
    </tr>
    <tr>
      <td>for...in para arrays</td>
      <td>for...of</td>
      <td>Para iterar sobre elementos de um array de forma mais segura e eficiente</td>
      <td>Iterar sobre elementos de um array</td>
      <td>Iteração mais segura e eficiente sobre arrays</td>
      <td>Quando não há necessidade de iterar sobre elementos de um array</td>
    </tr>
    <tr>
      <td>function</td>
      <td>Arrow functions (=&gt;)</td>
      <td>Para funções anônimas e manter o contexto do this</td>
      <td>Funções anônimas e callbacks</td>
      <td>Manter o contexto de this e sintaxe mais concisa</td>
      <td>Quando não há necessidade de criar funções dinâmicas</td>
    </tr>
    <tr>
      <td>function getData() { return new Promise((resolve, reject) =&gt; { ... }); }</td>
      <td>async function getData() { ... }</td>
      <td>Para lidar com promessas de forma mais simples e legível</td>
      <td>Funções assíncronas</td>
      <td>Simplificação de promessas</td>
      <td>Quando não há necessidade de operações assíncronas</td>
    </tr>
    <tr>
      <td>function resolveAfter2Seconds(x) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x), 2000)); }</td>
      <td>async function resolveAfter2Seconds(x) { return await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x), 2000)); }</td>
      <td>Para lidar com operações assíncronas de forma mais legível e gerenciável</td>
      <td>Operações assíncronas complexas</td>
      <td>Melhor legibilidade e manejo de fluxos assíncronos</td>
      <td>Quando não há operações assíncronas a serem realizadas</td>
    </tr>
    <tr>
      <td>function sum(a, b) { return a + b; }</td>
      <td>const sum = (a, b) =&gt; a + b;</td>
      <td>Para funções anônimas e manter o contexto do this</td>
      <td>Funções anônimas e callbacks</td>
      <td>Manter o contexto de this e sintaxe mais concisa</td>
      <td>Quando não há necessidade de criar funções dinâmicas</td>
    </tr>
    <tr>
      <td>function.call(context, arg1, arg2)</td>
      <td>function.apply(context, [arg1, arg2])</td>
      <td>Para passar um array de argumentos de forma mais eficiente e clara</td>
      <td>Passar arrays como argumentos</td>
      <td>Sintaxe mais legível para passar múltiplos argumentos</td>
      <td>Quando não há necessidade de passar múltiplos argumentos</td>
    </tr>
    <tr>
      <td>Function.prototype.apply</td>
      <td>Spread operator (...)</td>
      <td>Para passar arrays como argumentos de funções de forma mais legível</td>
      <td>Passar arrays como argumentos</td>
      <td>Sintaxe mais legível para passar múltiplos argumentos</td>
      <td>Quando não há necessidade de passar múltiplos argumentos</td>
    </tr>
    <tr>
      <td>Function.prototype.bind</td>
      <td>Arrow functions (=&gt;)</td>
      <td>Para preservar o contexto de this de forma mais concisa e legível</td>
      <td>Preservar contexto de this</td>
      <td>Sintaxe mais concisa e legível para funções anônimas</td>
      <td>Quando não há necessidade de preservar o contexto de this</td>
    </tr>
    <tr>
      <td>Funções IIFE para escopo</td>
      <td>Módulos ES6 (import/export)</td>
      <td>Para melhor modularização e reutilização de código, mantendo o escopo privado</td>
      <td>Modularização e escopo privado</td>
      <td>Melhor modularização e reutilização de código</td>
      <td>Quando não há necessidade de modularização de código</td>
    </tr>
    <tr>
      <td>getElementsByClassName</td>
      <td>querySelectorAll</td>
      <td>Para selecionar elementos DOM com mais flexibilidade e compatibilidade moderna</td>
      <td>Seleção de elementos DOM</td>
      <td>Seleção de elementos com mais flexibilidade e compatibilidade moderna</td>
      <td>Quando não há necessidade de selecionar elementos DOM</td>
    </tr>
    <tr>
      <td>HTMLElement.style.cssText</td>
      <td>CSSStyleDeclaration (ex. element.style.property = 'value')</td>
      <td>Para manipular estilos inline de forma mais controlada e eficiente</td>
      <td>Manipulação de estilos inline</td>
      <td>Forma mais controlada e eficiente de manipulação de estilos</td>
      <td>Quando não há necessidade de manipular estilos inline</td>
    </tr>
    <tr>
      <td>if (a == b) { ... }</td>
      <td>if (a === b) { ... }</td>
      <td>Para comparações rigorosas em JavaScript</td>
      <td>Comparações rigorosas</td>
      <td>Evitar erros de tipo nas comparações em JavaScript</td>
      <td>Quando não há necessidade de comparações rigorosas</td>
    </tr>
    <tr>
      <td>if (array.indexOf(element) !== -1) { ... }</td>
      <td>if (array.includes(element)) { ... }</td>
      <td>Para verificar se um array contém um elemento</td>
      <td>Verificação de elementos em arrays</td>
      <td>Sintaxe mais simples e legível</td>
      <td>Quando não há necessidade de verificar elementos em arrays</td>
    </tr>
    <tr>
      <td>if (obj &amp;&amp; obj.prop) { ... }</td>
      <td>if (obj?.prop) { ... }</td>
      <td>Para verificar propriedades de objetos</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e segura</td>
      <td>Quando não há necessidade de verificar propriedades</td>
    </tr>
    <tr>
      <td>if (obj.hasOwnProperty('key')) { ... }</td>
      <td>if (Object.hasOwn(obj, 'key')) { ... }</td>
      <td>Para verificar a propriedade de um objeto</td>
      <td>Manipulação de objetos</td>
      <td>Verificação mais segura de propriedades</td>
      <td>Quando não há necessidade de verificar propriedades</td>
    </tr>
    <tr>
      <td>if (obj.hasOwnProperty('prop')) { ... }</td>
      <td>if (Object.prototype.hasOwnProperty.call(obj, 'prop')) { ... }</td>
      <td>Para verificar a propriedade de um objeto</td>
      <td>Manipulação de objetos</td>
      <td>Verificação mais segura de propriedades</td>
      <td>Quando não há necessidade de verificar propriedades de objetos</td>
    </tr>
    <tr>
      <td>if (obj.hasOwnProperty('prop')) { ... }</td>
      <td>if (Object.hasOwn(obj, 'prop')) { ... }</td>
      <td>Para verificar a propriedade de um objeto de forma mais segura</td>
      <td>Manipulação de objetos</td>
      <td>Verificação mais segura de propriedades</td>
      <td>Quando não há necessidade de verificar propriedades</td>
    </tr>
    <tr>
      <td>if (str.startsWith('abc')) { ... }</td>
      <td>str.padStart(10, '0');</td>
      <td>Para preencher strings</td>
      <td>Manipulação de strings</td>
      <td>Melhor formatação de strings</td>
      <td>Quando não há necessidade de preencher strings</td>
    </tr>
    <tr>
      <td>Inline styles</td>
      <td>CSS classes</td>
      <td>Para separar estrutura e estilo, melhorar manutenção e performance</td>
      <td>Aplicação de estilos</td>
      <td>Separar estrutura HTML e estilo CSS, melhorar manutenção e performance</td>
      <td>Quando não há necessidade de alterar estilos</td>
    </tr>
    <tr>
      <td>innerHTML</td>
      <td>textContent</td>
      <td>Para inserir texto e evitar vulnerabilidades de XSS</td>
      <td>Elementos de texto estático</td>
      <td>Evitar vulnerabilidades de XSS ao inserir texto puro</td>
      <td>Quando não há necessidade de inserir texto dinamicamente</td>
    </tr>
    <tr>
      <td>JSON.parse(JSON.stringify(obj)) para clonar objetos</td>
      <td>structuredClone(obj)</td>
      <td>Para clonar objetos de forma mais eficiente e segura</td>
      <td>Clonar objetos</td>
      <td>Clonagem de objetos de forma eficiente e segura</td>
      <td>Quando não há necessidade de clonar objetos</td>
    </tr>
    <tr>
      <td>let xhr = new XMLHttpRequest();</td>
      <td>fetch(url).then(response =&gt; response.json()).then(data =&gt; console.log(data));</td>
      <td>Para fazer requisições assíncronas de forma mais simples e moderna</td>
      <td>Requisições HTTP assíncronas</td>
      <td>Simplicidade e promessa embutida para melhor gerenciamento de requisições</td>
      <td>Quando não há necessidade de fazer requisições HTTP</td>
    </tr>
    <tr>
      <td>Manipulação de classes com strings</td>
      <td>Manipulação de classes com classList</td>
      <td>Para adicionar, remover e alternar classes de forma mais eficiente e sem riscos de erros de digitação</td>
      <td>Manipulação de classes</td>
      <td>Adicionar, remover e alternar classes de forma mais eficiente e segura</td>
      <td>Quando não há necessidade de manipular classes</td>
    </tr>
    <tr>
      <td>Math.pow(2, 3);</td>
      <td>2 ** 3;</td>
      <td>Para realizar operações de potência</td>
      <td>Cálculos matemáticos</td>
      <td>Sintaxe mais concisa</td>
      <td>Quando não há necessidade de cálculos exponenciais</td>
    </tr>
    <tr>
      <td>Math.pow(2, 53) - 1;</td>
      <td>Number.MAX_SAFE_INTEGER;</td>
      <td>Para obter o maior número inteiro seguro</td>
      <td>Manipulação de números</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de manipular números grandes</td>
    </tr>
    <tr>
      <td>Math.pow(x, y);</td>
      <td>x ** y;</td>
      <td>Para realizar operações matemáticas de potência</td>
      <td>Cálculos matemáticos</td>
      <td>Sintaxe mais concisa e legível</td>
      <td>Quando não há necessidade de cálculos exponenciais</td>
    </tr>
    <tr>
      <td>Math.random()</td>
      <td>Cryptographically secure methods</td>
      <td>Para gerar números aleatórios seguros (ex. crypto.getRandomValues())</td>
      <td>Geração de números aleatórios em segurança</td>
      <td>Garantir segurança criptográfica, por exemplo, com crypto.getRandomValues()</td>
      <td>Quando não há necessidade de geração de números aleatórios</td>
    </tr>
    <tr>
      <td>navigator.getUserMedia</td>
      <td>navigator.mediaDevices.getUserMedia</td>
      <td>Para acessar a câmera e o microfone de forma mais segura e moderna</td>
      <td>Acesso à câmera e microfone</td>
      <td>Forma mais segura e moderna de acessar mídia do dispositivo</td>
      <td>Quando não há necessidade de acessar a câmera e o microfone</td>
    </tr>
    <tr>
      <td>new Date().getTime()</td>
      <td>Date.now()</td>
      <td>Para obter o timestamp atual de forma mais direta e eficiente</td>
      <td>Obter timestamp atual</td>
      <td>Forma mais direta e eficiente de obter o timestamp</td>
      <td>Quando não há necessidade de obter o timestamp atual</td>
    </tr>
    <tr>
      <td>new RegExp('pattern')</td>
      <td>Literal de expressão regular (/pattern/)</td>
      <td>Para criar expressões regulares de forma mais legível e eficiente</td>
      <td>Criação de expressões regulares</td>
      <td>Sintaxe mais legível e eficiente para criar expressões regulares</td>
      <td>Quando não há necessidade de criar expressões regulares</td>
    </tr>
    <tr>
      <td>Object.assign</td>
      <td>Spread operator (...)</td>
      <td>Para copiar propriedades de objetos de forma mais concisa e legível</td>
      <td>Copiar e combinar objetos e arrays</td>
      <td>Sintaxe mais concisa e legível para operações comuns</td>
      <td>Quando não há necessidade de copiar ou combinar objetos e arrays</td>
    </tr>
    <tr>
      <td>Object.entries(obj).forEach(([key, value]) =&gt; { obj[key] = value; });</td>
      <td>Object.fromEntries(Object.entries(obj).map(([key, value]) =&gt; [key, value]));</td>
      <td>Para transformar pares chave-valor em um objeto</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de transformar pares chave-valor</td>
    </tr>
    <tr>
      <td>Object.getOwnPropertyDescriptors(obj);</td>
      <td>Object.entries(obj).reduce((descriptors, [key, value]) =&gt; { descriptors[key] = { value }; return descriptors; }, {});</td>
      <td>Para obter descritores de propriedades</td>
      <td>Manipulação de objetos</td>
      <td>Sintaxe mais eficiente</td>
      <td>Quando não há necessidade de obter descritores de propriedades</td>
    </tr>
    <tr>
      <td>Object.prototype.hasOwnProperty</td>
      <td>Object.hasOwn</td>
      <td>Para verificar a propriedade de um objeto de forma mais segura e moderna</td>
      <td>Verificar propriedade de objeto</td>
      <td>Verificação mais segura e moderna de propriedades de objetos</td>
      <td>Quando não há necessidade de verificar propriedades de objetos</td>
    </tr>
    <tr>
      <td>Promise.resolve().then(() =&gt; { ... });</td>
      <td>async () =&gt; { ... }</td>
      <td>Para operações assíncronas</td>
      <td>Funções assíncronas</td>
      <td>Simplificação de operações assíncronas</td>
      <td>Quando não há necessidade de operações assíncronas</td>
    </tr>
    <tr>
      <td>promise.then(() =&gt; { /* success / }).catch(() =&gt; { / error / }).finally(() =&gt; { / always */ });</td>
      <td>promise.finally(() =&gt; { /* always */ });</td>
      <td>Para garantir que ações de limpeza sejam executadas independentemente do resultado da promessa</td>
      <td>Qualquer lugar onde promessas são usadas e necessitam de um bloco final de limpeza</td>
      <td>Reduz a duplicação de código</td>
      <td>Quando não há ações de limpeza necessárias após a promessa</td>
    </tr>
    <tr>
      <td>require()</td>
      <td>import/export</td>
      <td>Para modularização em JavaScript moderno (ES6+)</td>
      <td>Modularização de código JavaScript</td>
      <td>Melhor reutilização e manutenção de código em JavaScript moderno (ES6+)</td>
      <td>Quando não há necessidade de modularização de código</td>
    </tr>
    <tr>
      <td>setInterval</td>
      <td>requestAnimationFrame</td>
      <td>Para animações mais suaves e eficientes, sincronizadas com a taxa de atualização da tela</td>
      <td>Animações</td>
      <td>Animações mais suaves e eficientes, sincronizadas com a taxa de atualização da tela</td>
      <td>Quando não há necessidade de animações</td>
    </tr>
    <tr>
      <td>SQL Queries sem preparação</td>
      <td>Prepared Statements</td>
      <td>Para prevenir injeções SQL</td>
      <td>Consultas SQL dinâmicas</td>
      <td>Prevenir injeções SQL e melhorar a segurança</td>
      <td>Quando não há necessidade de consultas SQL dinâmicas</td>
    </tr>
    <tr>
      <td>String concatenation</td>
      <td>Template literals</td>
      <td>Para construir strings de forma mais eficiente e legível</td>
      <td>Construção de strings complexas</td>
      <td>Sintaxe mais legível e eficiente para interpolação de strings</td>
      <td>Quando não há necessidade de construção de strings complexas</td>
    </tr>
    <tr>
      <td>String.prototype.match</td>
      <td>RegExp.prototype.test</td>
      <td>Para testar uma string contra uma expressão regular de forma mais eficiente</td>
      <td>Testar strings contra expressões regulares</td>
      <td>Forma mais eficiente e legível de testar strings</td>
      <td>Quando não há necessidade de testar strings contra expressões regulares</td>
    </tr>
    <tr>
      <td>switch (response.status) { case 200: handleSuccess(); break; case 404: handleNotFound(); break; default: handleError(); }</td>
      <td>match (response.status) { when 200 -&gt; handleSuccess(), when 404 -&gt; handleNotFound(), when _ -&gt; handleError() }</td>
      <td>Para lógica condicional complexa</td>
      <td>Controle de fluxo</td>
      <td>Sintaxe mais clara e menos propensa a erros</td>
      <td>Quando não há necessidade de lógica condicional complexa</td>
    </tr>
    <tr>
      <td>try { ... } catch (e) { ... }</td>
      <td>try { ... } catch { ... }</td>
      <td>Para simplificar blocos try-catch</td>
      <td>Tratamento de exceções</td>
      <td>Sintaxe mais clara e eficiente</td>
      <td>Quando não há necessidade de tratamento de exceções</td>
    </tr>
    <tr>
      <td>try { ... } catch (error) { console.error(error); }</td>
      <td>try { ... } catch (error) { console.error('An error occurred:', error); }</td>
      <td>Para adicionar contexto a erros</td>
      <td>Tratamento de exceções</td>
      <td>Melhorar a depuração e rastreamento de erros</td>
      <td>Quando não há necessidade de tratamento de exceções</td>
    </tr>
    <tr>
      <td>try...catch</td>
      <td>Optional chaining (?.)</td>
      <td>Para acessar propriedades de objetos sem necessidade de try...catch</td>
      <td>Acesso a propriedades de objetos</td>
      <td>Evitar erros ao acessar propriedades inexistentes</td>
      <td>Quando não há necessidade de acessar propriedades de objetos</td>
    </tr>
    <tr>
      <td>try...catch sem finally</td>
      <td>try...catch...finally</td>
      <td>Para garantir a execução de código de limpeza ou finalização, independentemente do sucesso ou falha da operação</td>
      <td>Gerenciamento de exceções</td>
      <td>Garantir a execução de código de limpeza ou finalização</td>
      <td>Quando não há necessidade de tratamento de exceções</td>
    </tr>
    <tr>
      <td>Uso de eval para executar código dinamicamente</td>
      <td>Function constructor ou safer parsing methods</td>
      <td>Para evitar vulnerabilidades de segurança associadas ao eval</td>
      <td>Avaliação de código dinamicamente</td>
      <td>Evitar vulnerabilidades de segurança associadas ao uso de eval</td>
      <td>Quando não há necessidade de avaliação de código dinamicamente</td>
    </tr>
    <tr>
      <td>var</td>
      <td>let ou const</td>
      <td>Para declarar variáveis em ES6+; const para constantes, let para variáveis mutáveis</td>
      <td>Declaração de variáveis dentro de blocos ou funções</td>
      <td>Escopo de bloco para let e constantes imutáveis com const</td>
      <td>Quando não há necessidade de declarar novas variáveis</td>
    </tr>
    <tr>
      <td>var x = 10;</td>
      <td>let x = 10; const y = 20;</td>
      <td>Para declarar variáveis em ES6+</td>
      <td>Declaração de variáveis dentro de blocos ou funções</td>
      <td>Escopo de bloco para let e constantes imutáveis com const</td>
      <td>Quando não há necessidade de declarar novas variáveis</td>
    </tr>
    <tr>
      <td>window.location.href para redirecionamento</td>
      <td>window.location.assign ou window.location.replace</td>
      <td>Para redirecionamentos, com assign adicionando uma entrada no histórico e replace substituindo a atual</td>
      <td>Redirecionamentos</td>
      <td>assign para adicionar ao histórico, replace para substituir a entrada atual</td>
      <td>Quando não há necessidade de redirecionar</td>
    </tr>
    <tr>
      <td>window.onload</td>
      <td>DOMContentLoaded</td>
      <td>Para garantir que o DOM esteja totalmente carregado antes da execução</td>
      <td>Scripts que manipulam o DOM</td>
      <td>Garantir que o DOM esteja totalmente carregado antes da execução</td>
      <td>Quando não há scripts que manipulam o DOM</td>
    </tr>
    <tr>
      <td>XMLHttpRequest</td>
      <td>fetch</td>
      <td>Para fazer requisições assíncronas de forma mais simples e moderna</td>
      <td>Requisições HTTP assíncronas</td>
      <td>Simplicidade e promessa embutida para melhor gerenciamento de requisições</td>
      <td>Quando não há necessidade de fazer requisições HTTP</td>
    </tr>
    <tr>
      <td>XMLHttpRequest para requisições assíncronas</td>
      <td>async/await com fetch</td>
      <td>Para simplificar a escrita de código assíncrono e melhorar a legibilidade</td>
      <td>Requisições HTTP assíncronas</td>
      <td>Simplificar escrita de código assíncrono e melhorar legibilidade</td>
      <td>Quando não há necessidade de fazer requisições HTTP</td>
    </tr>
    <tr>
      <td>Promise.all</td>
      <td>Promise.allSettled</td>
      <td>Para lidar com múltiplas promessas, mesmo que algumas sejam rejeitadas</td>
      <td>Operações assíncronas em paralelo</td>
      <td>Obter resultados de todas as promessas, independentemente de sua resolução ou rejeição</td>
      <td>Quando é necessário que todas as promessas sejam resolvidas para prosseguir</td>
    </tr>
    <tr>
      <td>localStorage</td>
      <td>IndexedDB ou outras soluções de armazenamento modernas</td>
      <td>Para armazenamento de dados do lado do cliente, especialmente para grandes quantidades de dados estruturados</td>
      <td>Aplicativos web que requerem armazenamento local avançado</td>
      <td>Melhor desempenho, capacidade e recursos para armazenamento local</td>
      <td>Quando o armazenamento de dados é simples e limitado</td>
    </tr>
    <tr>
      <td>Callbacks aninhados (callback hell)</td>
      <td>Async/await com tratamento de erros try/catch</td>
      <td>Para simplificar e melhorar a legibilidade do código assíncrono</td>
      <td>Funções assíncronas complexas</td>
      <td>Evitar o aninhamento excessivo de callbacks e melhorar a clareza do fluxo de controle</td>
      <td>Quando não há operações assíncronas complexas</td>
    </tr>
    <tr>
      <td>Navegação por âncoras (#)</td>
      <td>API History</td>
      <td>Para navegação em SPAs (Single Page Applications)</td>
      <td>Aplicativos web de página única</td>
      <td>Melhor controle sobre o histórico de navegação e URLs mais limpas</td>
      <td>Quando a navegação tradicional por âncoras é suficiente</td>
    </tr>
    <tr>
      <td>CSS em linha</td>
      <td>CSS-in-JS ou CSS Modules</td>
      <td>Para estilos com escopo e melhor integração com JavaScript</td>
      <td>Aplicativos web modernos com componentização</td>
      <td>Melhor gerenciamento de estilos, escopo e dinâmica com JavaScript</td>
      <td>Quando os estilos são simples e não requerem escopo ou dinamicidade</td>
    </tr>
    <tr>
      <td>Renderização no servidor (SSR) com templates</td>
      <td>Renderização no servidor (SSR) com frameworks JavaScript (Next.js, Nuxt.js, etc.)</td>
      <td>Para melhorar o desempenho, SEO e experiência do usuário em aplicativos web</td>
      <td>Aplicativos web que requerem renderização no servidor</td>
      <td>Melhor desempenho, SEO e experiência do usuário com ferramentas modernas de SSR</td>
      <td>Quando a renderização no cliente é suficiente</td>
    </tr>
    <tr>
      <td>Testes manuais</td>
      <td>Testes automatizados (unitários, integração, e2e)</td>
      <td>Para garantir a qualidade e confiabilidade do código</td>
      <td>Em todo o ciclo de desenvolvimento</td>
      <td>Detectar regressões, melhorar a confiabilidade e facilitar a manutenção</td>
      <td>Quando o projeto é muito pequeno ou os testes manuais são suficientes</td>
    </tr>
    <tr>
      <td>Polling para atualizações em tempo real</td>
      <td>WebSockets, Server-Sent Events (SSE) ou WebRTC</td>
      <td>Para comunicação em tempo real eficiente entre cliente e servidor</td>
      <td>Aplicativos web que requerem atualizações em tempo real</td>
      <td>Melhor desempenho e eficiência na comunicação em tempo real</td>
      <td>Quando atualizações em tempo real não são necessárias</td>
    </tr>
    <tr>
      <td>Bibliotecas de UI (Bootstrap, Material-UI, etc.) com sobrescrita de estilos</td>
      <td>Sistemas de design (Design Systems) com componentes reutilizáveis</td>
      <td>Para manter consistência visual e facilitar a manutenção em grandes aplicativos</td>
      <td>Aplicativos web de grande escala com múltiplas equipes</td>
      <td>Melhorar a consistência, reutilização e manutenibilidade da interface do usuário</td>
      <td>Quando o aplicativo é pequeno ou não requer uma identidade visual forte</td>
    </tr>
    <tr>
      <td>Renderização no cliente (Client-Side Rendering) para todos os casos</td>
      <td>Renderização híbrida (SSR + CSR) com base em rotas ou componentes</td>
      <td>Para equilibrar desempenho, SEO e interatividade</td>
      <td>Aplicativos web modernos com requisitos variados</td>
      <td>Aproveitar os benefícios de SSR e CSR onde mais apropriado</td>
      <td>Quando o aplicativo é completamente estático ou completamente interativo</td>
    </tr>
  </tbody>
</table>

</body>
</html>
