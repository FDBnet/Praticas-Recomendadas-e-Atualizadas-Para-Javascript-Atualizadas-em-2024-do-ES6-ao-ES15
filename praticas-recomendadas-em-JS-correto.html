<html>
<head>
<title>Práticas recomendadas em JS</title>
</head>

<body>
<table><thead><tr><th>Antigo</th><th>Atual</th><th>Quando</th><th>Local de Uso</th><th>Motivo Específico</th><th>Quando Não Usar Nenhuma</th></tr></thead><tbody><tr><td><code>innerHTML</code></td><td><code>textContent</code></td><td>Para inserir texto e evitar vulnerabilidades de XSS</td><td>Elementos de texto estático</td><td>Evitar vulnerabilidades de XSS ao inserir texto puro</td><td>Quando não há necessidade de inserir texto dinamicamente</td></tr><tr><td><code>var</code></td><td><code>let</code> ou <code>const</code></td><td>Para declarar variáveis em ES6+; <code>const</code> para constantes, <code>let</code> para variáveis mutáveis</td><td>Declaração de variáveis dentro de blocos ou funções</td><td>Escopo de bloco para <code>let</code> e constantes imutáveis com <code>const</code></td><td>Quando não há necessidade de declarar novas variáveis</td></tr><tr><td><code>function</code></td><td>Arrow functions (<code>=&gt;</code>)</td><td>Para funções anônimas e manter o contexto do <code>this</code></td><td>Funções anônimas e callbacks</td><td>Manter o contexto de <code>this</code> e sintaxe mais concisa</td><td>Quando não há necessidade de criar funções dinâmicas</td></tr><tr><td><code>XMLHttpRequest</code></td><td><code>fetch</code></td><td>Para fazer requisições assíncronas de forma mais simples e moderna</td><td>Requisições HTTP assíncronas</td><td>Simplicidade e promessa embutida para melhor gerenciamento de requisições</td><td>Quando não há necessidade de fazer requisições HTTP</td></tr><tr><td>Callbacks</td><td>Promises ou <code>async/await</code></td><td>Para lidar com operações assíncronas de forma mais legível e gerenciável</td><td>Operações assíncronas complexas</td><td>Melhor legibilidade e manejo de fluxos assíncronos</td><td>Quando não há operações assíncronas a serem realizadas</td></tr><tr><td><code>document.write</code></td><td>DOM manipulation methods</td><td>Para evitar práticas inseguras e obsoletas de manipulação do DOM</td><td>Atualizações dinâmicas no DOM</td><td>Evitar práticas obsoletas e inseguras como <code>document.write</code></td><td>Quando não há necessidade de manipular o DOM</td></tr><tr><td>Inline styles</td><td>CSS classes</td><td>Para separar estrutura e estilo, melhorar manutenção e performance</td><td>Aplicação de estilos</td><td>Separar estrutura HTML e estilo CSS, melhorar manutenção e performance</td><td>Quando não há necessidade de alterar estilos</td></tr><tr><td><code>window.onload</code></td><td><code>DOMContentLoaded</code></td><td>Para garantir que o DOM esteja totalmente carregado antes da execução</td><td>Scripts que manipulam o DOM</td><td>Garantir que o DOM esteja totalmente carregado antes da execução</td><td>Quando não há scripts que manipulam o DOM</td></tr><tr><td><code>for</code> loops</td><td><code>for...of</code> ou <code>forEach</code></td><td>Para iterar sobre arrays de forma mais clara e moderna</td><td>Iterações sobre arrays</td><td>Sintaxe mais clara e moderna, melhorando a legibilidade</td><td>Quando não há necessidade de iterar sobre arrays</td></tr><tr><td><code>alert()</code></td><td>Custom modal dialogs</td><td>Para melhorar a usabilidade e a experiência do usuário</td><td>Mensagens e interações de usuário</td><td>Melhorar a experiência do usuário com interfaces modernas</td><td>Quando não há necessidade de mensagens ou interações de usuário</td></tr><tr><td><code>eval()</code></td><td>Secure parsing functions</td><td>Para evitar vulnerabilidades de segurança</td><td>Avaliação de código dinamicamente</td><td>Evitar vulnerabilidades de segurança associadas ao uso de <code>eval</code></td><td>Quando não há necessidade de avaliação de código dinamicamente</td></tr><tr><td><code>Math.random()</code></td><td>Cryptographically secure methods</td><td>Para gerar números aleatórios seguros (ex. <code>crypto.getRandomValues()</code>)</td><td>Geração de números aleatórios em segurança</td><td>Garantir segurança criptográfica, por exemplo, com <code>crypto.getRandomValues()</code></td><td>Quando não há necessidade de geração de números aleatórios</td></tr><tr><td>String concatenation</td><td>Template literals</td><td>Para construir strings de forma mais eficiente e legível</td><td>Construção de strings complexas</td><td>Sintaxe mais legível e eficiente para interpolação de strings</td><td>Quando não há necessidade de construção de strings complexas</td></tr><tr><td>SQL Queries sem preparação</td><td>Prepared Statements</td><td>Para prevenir injeções SQL</td><td>Consultas SQL dinâmicas</td><td>Prevenir injeções SQL e melhorar a segurança</td><td>Quando não há necessidade de consultas SQL dinâmicas</td></tr><tr><td><code>require()</code></td><td><code>import</code>/<code>export</code></td><td>Para modularização em JavaScript moderno (ES6+)</td><td>Modularização de código JavaScript</td><td>Melhor reutilização e manutenção de código em JavaScript moderno (ES6+)</td><td>Quando não há necessidade de modularização de código</td></tr><tr><td><code>console.log</code></td><td>Logging frameworks</td><td>Para um logging mais robusto e gerenciável em produção</td><td>Aplicações em produção</td><td>Logging mais robusto e gerenciável</td><td>Quando não há necessidade de logging em produção</td></tr><tr><td><code>==</code></td><td><code>===</code></td><td>Para comparações rigorosas em JavaScript</td><td>Comparações rigorosas</td><td>Evitar erros de tipo nas comparações em JavaScript</td><td>Quando não há necessidade de comparações rigorosas</td></tr><tr><td><code>Array.prototype.map</code></td><td><code>Array.from</code></td><td>Para criar arrays a partir de objetos iteráveis ou pseudo-arrays</td><td>Criação de arrays a partir de objetos iteráveis</td><td>Melhor suporte a objetos pseudo-arrays e iteráveis</td><td>Quando não há necessidade de criar arrays a partir de objetos iteráveis</td></tr><tr><td><code>Object.assign</code></td><td>Spread operator (<code>...</code>)</td><td>Para copiar propriedades de objetos de forma mais concisa e legível</td><td>Copiar e combinar objetos e arrays</td><td>Sintaxe mais concisa e legível para operações comuns</td><td>Quando não há necessidade de copiar ou combinar objetos e arrays</td></tr><tr><td><code>try...catch</code></td><td><code>Optional chaining (?.)</code></td><td>Para acessar propriedades de objetos sem necessidade de try...catch</td><td>Acesso a propriedades de objetos</td><td>Evitar erros ao acessar propriedades inexistentes</td><td>Quando não há necessidade de acessar propriedades de objetos</td></tr><tr><td><code>new Date().getTime()</code></td><td><code>Date.now()</code></td><td>Para obter o timestamp atual de forma mais direta e eficiente</td><td>Obter timestamp atual</td><td>Forma mais direta e eficiente de obter o timestamp</td><td>Quando não há necessidade de obter o timestamp atual</td></tr><tr><td><code>for...in</code></td><td><code>Object.keys/values/entries</code></td><td>Para iterar sobre as propriedades de objetos de forma mais segura</td><td>Iterar sobre propriedades de objetos</td><td>Iteração mais segura e controlada sobre propriedades de objetos</td><td>Quando não há necessidade de iterar sobre as propriedades de objetos</td></tr><tr><td><code>document.getElementById</code></td><td><code>document.querySelector</code></td><td>Para selecionar elementos DOM com mais flexibilidade e consistência</td><td>Seleção de elementos DOM</td><td>Flexibilidade e consistência na seleção de elementos</td><td>Quando não há necessidade de selecionar elementos DOM</td></tr><tr><td><code>event.srcElement</code></td><td><code>event.target</code></td><td>Para acessar o elemento que disparou o evento de forma mais consistente</td><td>Acesso ao elemento que disparou o evento</td><td>Acesso consistente e confiável ao alvo do evento</td><td>Quando não há eventos sendo disparados</td></tr><tr><td><code>Function.prototype.apply</code></td><td>Spread operator (<code>...</code>)</td><td>Para passar arrays como argumentos de funções de forma mais legível</td><td>Passar arrays como argumentos</td><td>Sintaxe mais legível para passar múltiplos argumentos</td><td>Quando não há necessidade de passar múltiplos argumentos</td></tr><tr><td><code>Array.prototype.concat</code></td><td>Spread operator (<code>...</code>)</td><td>Para combinar arrays de forma mais eficiente e legível</td><td>Combinar objetos e arrays</td><td>Sintaxe mais concisa e legível para combinar objetos e arrays</td><td>Quando não há necessidade de combinar arrays</td></tr><tr><td><code>document.createElement</code> e <code>appendChild</code></td><td><code>Element.insertAdjacentHTML</code></td><td>Para inserir elementos HTML de forma mais direta e eficiente</td><td>Inserção de HTML dinâmico</td><td>Inserção mais eficiente e segura de conteúdo HTML</td><td>Quando não há necessidade de inserir HTML dinamicamente</td></tr><tr><td><code>element.className = '...'</code></td><td><code>element.classList.add/remove/toggle</code></td><td>Para manipular classes de elementos de forma mais eficiente e flexível</td><td>Manipulação de classes de elementos</td><td>Sintaxe mais clara e eficiente para manipulação de classes</td><td>Quando não há necessidade de manipular classes de elementos</td></tr><tr><td><code>function.call(context, arg1, arg2)</code></td><td><code>function.apply(context, [arg1, arg2])</code></td><td>Para passar um array de argumentos de forma mais eficiente e clara</td><td>Passar arrays como argumentos</td><td>Sintaxe mais legível para passar múltiplos argumentos</td><td>Quando não há necessidade de passar múltiplos argumentos</td></tr><tr><td><code>new RegExp('pattern')</code></td><td>Literal de expressão regular (<code>/pattern/</code>)</td><td>Para criar expressões regulares de forma mais legível e eficiente</td><td>Criação de expressões regulares</td><td>Sintaxe mais legível e eficiente para criar expressões regulares</td><td>Quando não há necessidade de criar expressões regulares</td></tr><tr><td><code>Array.prototype.findIndex</code></td><td><code>Array.prototype.find</code></td><td>Para encontrar o primeiro item que satisfaça uma condição de forma mais eficiente e legível</td><td>Encontrar item em um array</td><td>Forma mais eficiente e legível de encontrar o primeiro item que satisfaça uma condição</td><td>Quando não há necessidade de encontrar itens em um array</td></tr><tr><td><code>for...in</code> para arrays</td><td><code>for...of</code></td><td>Para iterar sobre elementos de um array de forma mais segura e eficiente</td><td>Iterar sobre elementos de um array</td><td>Iteração mais segura e eficiente sobre arrays</td><td>Quando não há necessidade de iterar sobre elementos de um array</td></tr><tr><td><code>JSON.parse(JSON.stringify(obj))</code> para clonar objetos</td><td><code>structuredClone(obj)</code></td><td>Para clonar objetos de forma mais eficiente e segura</td><td>Clonar objetos</td><td>Clonagem de objetos de forma eficiente e segura</td><td>Quando não há necessidade de clonar objetos</td></tr><tr><td><code>element.removeNode</code></td><td><code>element.remove</code></td><td>Para remover elementos do DOM de forma mais moderna e suportada</td><td>Remover elementos do DOM</td><td>Método moderno e suportado para remover elementos</td><td>Quando não há necessidade de remover elementos do DOM</td></tr><tr><td><code>element.innerHTML += '...'</code></td><td><code>element.insertAdjacentHTML</code></td><td>Para adicionar HTML de forma mais eficiente e segura</td><td>Adicionar HTML dinâmico</td><td>Forma mais eficiente e segura de adicionar HTML ao DOM</td><td>Quando não há necessidade de adicionar HTML dinamicamente</td></tr><tr><td><code>element.setAttribute('style', '...')</code></td><td><code>element.style.property = '...'</code></td><td>Para manipular estilos inline de forma mais clara e controlada</td><td>Manipulação de estilos inline</td><td>Forma mais clara e controlada de manipular estilos</td><td>Quando não há necessidade de manipular estilos</td></tr><tr><td><code>document.cookie</code></td><td><code>localStorage</code> ou <code>sessionStorage</code></td><td>Para armazenar dados no cliente de forma mais segura e gerenciável</td><td>Armazenamento de dados no cliente</td><td>Armazenamento mais seguro e gerenciável de dados do cliente</td><td>Quando não há necessidade de armazenar dados no cliente</td></tr><tr><td><code>HTMLElement.style.cssText</code></td><td><code>CSSStyleDeclaration</code> (ex. <code>element.style.property = 'value'</code>)</td><td>Para manipular estilos inline de forma mais controlada e eficiente</td><td>Manipulação de estilos inline</td><td>Forma mais controlada e eficiente de manipulação de estilos</td><td>Quando não há necessidade de manipular estilos inline</td></tr><tr><td><code>element.attachEvent</code></td><td><code>element.addEventListener</code></td><td>Para adicionar eventos de forma mais padronizada e moderna</td><td>Adicionar eventos</td><td>Adição de eventos de forma padronizada e moderna</td><td>Quando não há necessidade de adicionar eventos</td></tr><tr><td><code>document.createEvent</code></td><td><code>new Event</code> ou <code>CustomEvent</code></td><td>Para criar eventos personalizados de forma mais moderna e padronizada</td><td>Criação de eventos personalizados</td><td>Forma mais moderna e padronizada de criar eventos</td><td>Quando não há necessidade de criar eventos personalizados</td></tr><tr><td><code>String.prototype.match</code></td><td><code>RegExp.prototype.test</code></td><td>Para testar uma string contra uma expressão regular de forma mais eficiente</td><td>Testar strings contra expressões regulares</td><td>Forma mais eficiente e legível de testar strings</td><td>Quando não há necessidade de testar strings contra expressões regulares</td></tr><tr><td><code>Array.prototype.splice</code> para remover itens</td><td><code>Array.prototype.filter</code></td><td>Para remover itens de um array de forma mais clara e imutável</td><td>Remover itens de um array</td><td>Forma mais clara e imutável de remover itens de um array</td><td>Quando não há necessidade de remover itens de um array</td></tr><tr><td><code>Object.prototype.hasOwnProperty</code></td><td><code>Object.hasOwn</code></td><td>Para verificar a propriedade de um objeto de forma mais segura e moderna</td><td>Verificar propriedade de objeto</td><td>Verificação mais segura e moderna de propriedades de objetos</td><td>Quando não há necessidade de verificar propriedades de objetos</td></tr><tr><td><code>Function.prototype.bind</code></td><td>Arrow functions (<code>=&gt;</code>)</td><td>Para preservar o contexto de <code>this</code> de forma mais concisa e legível</td><td>Preservar contexto de <code>this</code></td><td>Sintaxe mais concisa e legível para funções anônimas</td><td>Quando não há necessidade de preservar o contexto de <code>this</code></td></tr><tr><td><code>try...catch</code> sem finally</td><td><code>try...catch...finally</code></td><td>Para garantir a execução de código de limpeza ou finalização, independentemente do sucesso ou falha da operação</td><td>Gerenciamento de exceções</td><td>Garantir a execução de código de limpeza ou finalização</td><td>Quando não há necessidade de tratamento de exceções</td></tr><tr><td><code>Element.offsetTop</code> e <code>Element.offsetLeft</code></td><td><code>Element.getBoundingClientRect()</code></td><td>Para obter informações de posição e tamanho de elementos de forma mais precisa</td><td>Obter informações de posição e tamanho de elementos</td><td>Forma mais precisa e moderna de obter informações de posição e tamanho</td><td>Quando não há necessidade de obter informações de posição e tamanho</td></tr><tr><td><code>XMLHttpRequest</code> para requisições assíncronas</td><td><code>async/await</code> com <code>fetch</code></td><td>Para simplificar a escrita de código assíncrono e melhorar a legibilidade</td><td>Requisições HTTP assíncronas</td><td>Simplificar escrita de código assíncrono e melhorar legibilidade</td><td>Quando não há necessidade de fazer requisições HTTP</td></tr><tr><td>Manipulação de classes com strings</td><td>Manipulação de classes com <code>classList</code></td><td>Para adicionar, remover e alternar classes de forma mais eficiente e sem riscos de erros de digitação</td><td>Manipulação de classes</td><td>Adicionar, remover e alternar classes de forma mais eficiente e segura</td><td>Quando não há necessidade de manipular classes</td></tr><tr><td>Funções IIFE para escopo</td><td>Módulos ES6 (<code>import</code>/<code>export</code>)</td><td>Para melhor modularização e reutilização de código, mantendo o escopo privado</td><td>Modularização e escopo privado</td><td>Melhor modularização e reutilização de código</td><td>Quando não há necessidade de modularização de código</td></tr><tr><td>Callback hell</td><td>Promises ou <code>async/await</code></td><td>Para evitar aninhamento excessivo de callbacks e melhorar a legibilidade do código</td><td>Operações assíncronas complexas</td><td>Melhor legibilidade e manejo de fluxos assíncronos</td><td>Quando não há operações assíncronas a serem realizadas</td></tr><tr><td><code>Array.prototype.reduce</code> para somar valores</td><td><code>Array.prototype.reduce</code> com arrow function</td><td>Para melhorar a clareza e concisão ao usar a função de redução</td><td>Soma de valores em arrays</td><td>Forma mais clara e concisa de usar a função de redução</td><td>Quando não há necessidade de somar valores em arrays</td></tr><tr><td>Uso de <code>eval</code> para executar código dinamicamente</td><td><code>Function</code> constructor ou safer parsing methods</td><td>Para evitar vulnerabilidades de segurança associadas ao <code>eval</code></td><td>Avaliação de código dinamicamente</td><td>Evitar vulnerabilidades de segurança associadas ao uso de <code>eval</code></td><td>Quando não há necessidade de avaliação de código dinamicamente</td></tr><tr><td><code>document.body.scrollTop</code></td><td><code>window.scrollY</code></td><td>Para obter a posição de rolagem vertical de forma mais precisa e moderna</td><td>Obter posição de rolagem vertical</td><td>Forma mais precisa e moderna de obter a posição de rolagem vertical</td><td>Quando não há necessidade de obter a posição de rolagem vertical</td></tr><tr><td><code>element.children</code></td><td><code>element.childNodes</code></td><td>Para obter todos os nós filhos, incluindo nós de texto e comentário</td><td>Obter todos os nós filhos</td><td>Forma mais abrangente de obter todos os nós filhos, incluindo nós de texto e comentário</td><td>Quando não há necessidade de obter todos os nós filhos</td></tr><tr><td><code>navigator.getUserMedia</code></td><td><code>navigator.mediaDevices.getUserMedia</code></td><td>Para acessar a câmera e o microfone de forma mais segura e moderna</td><td>Acesso à câmera e microfone</td><td>Forma mais segura e moderna de acessar mídia do dispositivo</td><td>Quando não há necessidade de acessar a câmera e o microfone</td></tr><tr><td><code>document.execCommand('copy')</code></td><td><code>navigator.clipboard.writeText</code></td><td>Para copiar texto para a área de transferência de forma mais segura e moderna</td><td>Copiar texto para a área de transferência</td><td>Forma mais segura e moderna de copiar texto para a área de transferência</td><td>Quando não há necessidade de copiar texto para a área de transferência</td></tr><tr><td><code>window.location.href</code> para redirecionamento</td><td><code>window.location.assign</code> ou <code>window.location.replace</code></td><td>Para redirecionamentos, com <code>assign</code> adicionando uma entrada no histórico e <code>replace</code> substituindo a atual</td><td>Redirecionamentos</td><td><code>assign</code> para adicionar ao histórico, <code>replace</code> para substituir a entrada atual</td><td>Quando não há necessidade de redirecionar</td></tr><tr><td><code>element.scrollIntoView</code> com opções padrão</td><td><code>element.scrollIntoView({ behavior: 'smooth' })</code></td><td>Para uma rolagem suave ao elemento</td><td>Rolagem suave ao elemento</td><td>Melhorar a experiência do usuário com rolagem suave</td><td>Quando não há necessidade de rolar até um elemento</td></tr><tr><td><code>setInterval</code></td><td><code>requestAnimationFrame</code></td><td>Para animações mais suaves e eficientes, sincronizadas com a taxa de atualização da tela</td><td>Animações</td><td>Animações mais suaves e eficientes, sincronizadas com a taxa de atualização da tela</td><td>Quando não há necessidade de animações</td></tr><tr><td><code>getElementsByClassName</code></td><td><code>querySelectorAll</code></td><td>Para selecionar elementos DOM com mais flexibilidade e compatibilidade moderna</td><td>Seleção de elementos DOM</td><td>Seleção de elementos com mais flexibilidade e compatibilidade moderna</td><td>Quando não há necessidade de selecionar elementos DOM</td></tr><tr><td><code>document.forms['formName']</code></td><td><code>document.querySelector('form[name="formName"]')</code></td><td>Para selecionar formulários de forma mais moderna e flexível</td><td>Seleção de formulários</td><td>Seleção de formulários de forma mais moderna e flexível</td><td>Quando não há necessidade de selecionar formulários</td></tr></tbody>
<tbody><tr><td>var x = 10;</td><td>let x = 10; const y = 20;</td><td>Para declarar variáveis em ES6+</td><td>Declaração de variáveis dentro de blocos ou funções</td><td>Escopo de bloco para let e constantes imutáveis com const</td><td>Quando não há necessidade de declarar novas variáveis</td></tr><tr><td>function sum(a, b) { return a + b; }</td><td>const sum = (a, b) =&gt; a + b;</td><td>Para funções anônimas e manter o contexto do this</td><td>Funções anônimas e callbacks</td><td>Manter o contexto de this e sintaxe mais concisa</td><td>Quando não há necessidade de criar funções dinâmicas</td></tr><tr><td>let xhr = new XMLHttpRequest();</td><td>fetch(url).then(response =&gt; response.json()).then(data =&gt; console.log(data));</td><td>Para fazer requisições assíncronas de forma mais simples e moderna</td><td>Requisições HTTP assíncronas</td><td>Simplicidade e promessa embutida para melhor gerenciamento de requisições</td><td>Quando não há necessidade de fazer requisições HTTP</td></tr><tr><td>document.write('Hello World');</td><td>document.getElementById('example').textContent = 'Hello World';</td><td>Para evitar práticas inseguras e obsoletas de manipulação do DOM</td><td>Atualizações dinâmicas no DOM</td><td>Evitar práticas obsoletas e inseguras como document.write</td><td>Quando não há necessidade de manipular o DOM</td></tr><tr><td>element.setAttribute('style', 'color: red');</td><td>element.style.color = 'red';</td><td>Para manipular estilos inline de forma mais clara e controlada</td><td>Manipulação de estilos inline</td><td>Forma mais clara e controlada de manipular estilos</td><td>Quando não há necessidade de manipular estilos</td></tr><tr><td>if (a == b) { ... }</td><td>if (a === b) { ... }</td><td>Para comparações rigorosas em JavaScript</td><td>Comparações rigorosas</td><td>Evitar erros de tipo nas comparações em JavaScript</td><td>Quando não há necessidade de comparações rigorosas</td></tr><tr><td>Math.pow(x, y);</td><td>x ** y;</td><td>Para realizar operações matemáticas de potência</td><td>Cálculos matemáticos</td><td>Sintaxe mais concisa e legível</td><td>Quando não há necessidade de cálculos exponenciais</td></tr><tr><td>function resolveAfter2Seconds(x) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x), 2000)); }</td><td>async function resolveAfter2Seconds(x) { return await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x), 2000)); }</td><td>Para lidar com operações assíncronas de forma mais legível e gerenciável</td><td>Operações assíncronas complexas</td><td>Melhor legibilidade e manejo de fluxos assíncronos</td><td>Quando não há operações assíncronas a serem realizadas</td></tr><tr><td>const data = { name: 'Alice', age: 25 }; const name = data.name; const age = data.age;</td><td>const { name, age } = data;</td><td>Para extrair valores de objetos de forma concisa</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de extrair valores</td></tr><tr><td>const arr = [1, 2, 3]; const newArr = arr.map(x =&gt; x * 2);</td><td>const newArr = arr.flatMap(x =&gt; [x, x * 2]);</td><td>Para manipular arrays de forma eficiente</td><td>Manipulação de arrays</td><td>Sintaxe mais eficiente e legível</td><td>Quando não há necessidade de manipular arrays</td></tr><tr><td>if (array.indexOf(element) !== -1) { ... }</td><td>if (array.includes(element)) { ... }</td><td>Para verificar se um array contém um elemento</td><td>Verificação de elementos em arrays</td><td>Sintaxe mais simples e legível</td><td>Quando não há necessidade de verificar elementos em arrays</td></tr><tr><td>Math.pow(2, 3);</td><td>2 ** 3;</td><td>Para realizar operações de potência</td><td>Cálculos matemáticos</td><td>Sintaxe mais concisa</td><td>Quando não há necessidade de cálculos exponenciais</td></tr><tr><td>function getData() { return new Promise((resolve, reject) =&gt; { ... }); }</td><td>async function getData() { ... }</td><td>Para lidar com promessas de forma mais simples e legível</td><td>Funções assíncronas</td><td>Simplificação de promessas</td><td>Quando não há necessidade de operações assíncronas</td></tr><tr><td>const values = Object.keys(obj).map(key =&gt; obj[key]);</td><td>const values = Object.values(obj);</td><td>Para obter valores de um objeto</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de obter valores de objetos</td></tr><tr><td>const entries = Object.keys(obj).map(key =&gt; [key, obj[key]]);</td><td>const entries = Object.entries(obj);</td><td>Para obter pares chave-valor de um objeto</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de obter pares chave-valor de objetos</td></tr><tr><td>if (str.startsWith('abc')) { ... }</td><td>str.padStart(10, '0');</td><td>Para preencher strings</td><td>Manipulação de strings</td><td>Melhor formatação de strings</td><td>Quando não há necessidade de preencher strings</td></tr><tr><td>if (obj.hasOwnProperty('prop')) { ... }</td><td>if (Object.prototype.hasOwnProperty.call(obj, 'prop')) { ... }</td><td>Para verificar a propriedade de um objeto</td><td>Manipulação de objetos</td><td>Verificação mais segura de propriedades</td><td>Quando não há necessidade de verificar propriedades de objetos</td></tr><tr><td>const obj = { a: 1, b: 2 }; const copy = Object.assign({}, obj);</td><td>const copy = { ...obj };</td><td>Para copiar propriedades de objetos</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de copiar objetos</td></tr><tr><td>const newArr = []; arr.forEach(item =&gt; newArr.push(item * 2));</td><td>const newArr = arr.map(item =&gt; item * 2);</td><td>Para transformar elementos de um array</td><td>Transformação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de transformar arrays</td></tr><tr><td>arr.concat(arr2);</td><td>const merged = [...arr, ...arr2];</td><td>Para mesclar arrays</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de mesclar arrays</td></tr><tr><td>try { ... } catch (e) { ... }</td><td>try { ... } catch { ... }</td><td>Para simplificar blocos try-catch</td><td>Tratamento de exceções</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de tratamento de exceções</td></tr><tr><td>Promise.resolve().then(() =&gt; { ... });</td><td>async () =&gt; { ... }</td><td>Para operações assíncronas</td><td>Funções assíncronas</td><td>Simplificação de operações assíncronas</td><td>Quando não há necessidade de operações assíncronas</td></tr><tr><td>Object.getOwnPropertyDescriptors(obj);</td><td>Object.entries(obj).reduce((descriptors, [key, value]) =&gt; { descriptors[key] = { value }; return descriptors; }, {});</td><td>Para obter descritores de propriedades</td><td>Manipulação de objetos</td><td>Sintaxe mais eficiente</td><td>Quando não há necessidade de obter descritores de propriedades</td></tr><tr><td>for (const value of asyncIterable) { await someFunction(value); }</td><td>for await (const value of asyncIterable) { await someFunction(value); }</td><td>Para iterar sobre dados assíncronos</td><td>Funções assíncronas que processam listas de dados</td><td>Simplifica o código e melhora a legibilidade ao lidar com promessas em loop</td><td>Quando não há necessidade de iteração assíncrona</td></tr><tr><td>promise.then(() =&gt; { /* success <em>/ }).catch(() =&gt; { /</em> error <em>/ }).finally(() =&gt; { /</em> always */ });</td><td>promise.finally(() =&gt; { /* always */ });</td><td>Para garantir que ações de limpeza sejam executadas independentemente do resultado da promessa</td><td>Qualquer lugar onde promessas são usadas e necessitam de um bloco final de limpeza</td><td>Reduz a duplicação de código</td><td>Quando não há ações de limpeza necessárias após a promessa</td></tr><tr><td>const newObj = Object.assign({}, obj1, obj2);</td><td>const newObj = { ...obj1, ...obj2 };</td><td>Para clonar ou combinar objetos de forma eficiente</td><td>Manipulação de objetos, especialmente em funções de utilidade</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de clonar ou combinar objetos</td></tr><tr><td>const regex = new RegExp('pattern', 'flags');</td><td>const regex = /pattern/flags;</td><td>Para buscas avançadas em strings e correspondências complexas</td><td>Processamento de strings, validação de entradas</td><td>Poderoso e flexível para correspondência de padrões</td><td>Quando simples correspondências de padrões são suficientes</td></tr><tr><td>const path = 'C:\\path\\to\\file';</td><td>const path = String.raw<code>C:\\path\\to\\file</code>;</td><td>Para evitar processamento de escape sequences</td><td>Strings de caminho de arquivo, regex complexas</td><td>Evita erros de escape e melhora a legibilidade</td><td>Quando não há necessidade de strings não processadas</td></tr></tbody>
<tbody><tr><td>array.flat();</td><td>const flatArray = array.flat();</td><td>Para aplanar arrays aninhados</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de aplanar arrays</td></tr><tr><td>array.flatMap(x =&gt; [x * 2]);</td><td>const flatMappedArray = array.flatMap(x =&gt; [x, x * 2]);</td><td>Para transformar e aplanar arrays</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de transformar e aplanar arrays</td></tr><tr><td>Math.pow(2, 53) - 1;</td><td>Number.MAX_SAFE_INTEGER;</td><td>Para obter o maior número inteiro seguro</td><td>Manipulação de números</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de manipular números grandes</td></tr><tr><td>Object.entries(obj).forEach(([key, value]) =&gt; { obj[key] = value; });</td><td>Object.fromEntries(Object.entries(obj).map(([key, value]) =&gt; [key, value]));</td><td>Para transformar pares chave-valor em um objeto</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de transformar pares chave-valor</td></tr><tr><td>const global = Function('return this')();</td><td>globalThis;</td><td>Para acessar o objeto global</td><td>Manipulação de escopo global</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de acessar o objeto global</td></tr><tr><td>const str = ' Hello World '; str.trim();</td><td>str.trimStart(); str.trimEnd();</td><td>Para remover espaços em branco do início e do fim de strings</td><td>Manipulação de strings</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de remover espaços em branco</td></tr><tr><td>const bigInt = BigInt(1234567890);</td><td>const bigInt = 1234567890n;</td><td>Para criar BigInts</td><td>Manipulação de números grandes</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de manipular números grandes</td></tr><tr><td>arr.map(el =&gt; el * 2);</td><td>arr.map(el =&gt; el * 2).filter(el =&gt; el &gt; 2);</td><td>Para transformar e filtrar arrays</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de transformar e filtrar arrays</td></tr><tr><td>const obj = {}; if (obj.a) { obj.a(); }</td><td>obj.a?.();</td><td>Para evitar erros de acesso a propriedades</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e segura</td><td>Quando não há necessidade de acessar propriedades</td></tr><tr><td>const val = a</td><td></td><td>b;</td><td>const val = a ?? b;</td><td>Para atribuir valores padrão</td><td>Atribuição de valores</td></tr><tr><td>if (obj.hasOwnProperty('key')) { ... }</td><td>if (Object.hasOwn(obj, 'key')) { ... }</td><td>Para verificar a propriedade de um objeto</td><td>Manipulação de objetos</td><td>Verificação mais segura de propriedades</td><td>Quando não há necessidade de verificar propriedades</td></tr><tr><td>arr.filter(Boolean);</td><td>arr.filter(el =&gt; el);</td><td>Para remover valores falsy de arrays</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de remover valores falsy</td></tr><tr><td>const merged = Object.assign({}, obj1, obj2);</td><td>const merged = { ...obj1, ...obj2 };</td><td>Para mesclar objetos</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de mesclar objetos</td></tr><tr><td>const obj = {}; if (!obj.prop) { obj.prop = 'default'; }</td><td>obj.prop</td><td></td><td>= 'default';</td><td>Para atribuir valores padrão</td><td>Atribuição de valores</td></tr><tr><td>if (obj &amp;&amp; obj.prop) { ... }</td><td>if (obj?.prop) { ... }</td><td>Para verificar propriedades de objetos</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e segura</td><td>Quando não há necessidade de verificar propriedades</td></tr><tr><td>const value = (obj &amp;&amp; obj.value)</td><td></td><td>'default';</td><td>const value = obj?.value ?? 'default';</td><td>Para atribuir valores padrão de forma mais segura</td><td>Atribuição de valores</td></tr><tr><td>const str = 'abc'; const regex = /a/; const result = str.match(regex);</td><td>const result = 'abc'.match(/a/);</td><td>Para simplificar a busca de padrões em strings</td><td>Manipulação de strings</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de buscar padrões</td></tr><tr><td>class MyClass { constructor() { this.myField = 'value'; } }</td><td>class MyClass { myField = 'value'; }</td><td>Para definir campos de classe de forma mais concisa</td><td>Declaração de classes</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de definir campos de classe</td></tr><tr><td>class MyClass { constructor() { this.myField = 'value'; } }</td><td>class MyClass { static myField = 'value'; }</td><td>Para definir campos estáticos de classe</td><td>Declaração de classes</td><td>Melhor organização e acessibilidade de dados estáticos</td><td>Quando não há necessidade de definir campos estáticos</td></tr><tr><td>try { ... } catch (error) { console.error(error); }</td><td>try { ... } catch (error) { console.error('An error occurred:', error); }</td><td>Para adicionar contexto a erros</td><td>Tratamento de exceções</td><td>Melhorar a depuração e rastreamento de erros</td><td>Quando não há necessidade de tratamento de exceções</td></tr><tr><td>arr[-1];</td><td>arr.at(-1);</td><td>Para acessar elementos de arrays com índices negativos</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de acessar elementos de arrays com índices negativos</td></tr><tr><td>if (obj.hasOwnProperty('prop')) { ... }</td><td>if (Object.hasOwn(obj, 'prop')) { ... }</td><td>Para verificar a propriedade de um objeto de forma mais segura</td><td>Manipulação de objetos</td><td>Verificação mais segura de propriedades</td><td>Quando não há necessidade de verificar propriedades</td></tr><tr><td>const numbers = [1, 2, 3]; const reversed = numbers.reverse();</td><td>const reversed = numbers.toReversed();</td><td>Para reverter arrays sem modificar o original</td><td>Manipulação de arrays</td><td>Evitar mutação do array original</td><td>Quando não há necessidade de reverter arrays</td></tr><tr><td>const response = await fetch(url); const data = await response.json();</td><td>const data = await fetch(url).then(response =&gt; response.json());</td><td>Para simplificar chamadas de API assíncronas</td><td>Requisições HTTP assíncronas</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de fazer requisições HTTP</td></tr><tr><td>const sym = Symbol('description');</td><td>const sym = Symbol.for('description');</td><td>Para compartilhar símbolos entre diferentes partes do código</td><td>Manipulação de símbolos</td><td>Reutilização de símbolos</td><td>Quando não há necessidade de compartilhar símbolos</td></tr><tr><td>const str = '\uD800'; const isWellFormed = /^[^\uD800-\uDFFF]$/u.test(str);</td><td>const isWellFormed = str.isWellFormed();</td><td>Para verificar se uma string está bem formada</td><td>Manipulação de strings</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de verificar strings</td></tr><tr><td>Atomics.wait(typedArray, index, value);</td><td>Atomics.waitSync(typedArray, index, value);</td><td>Para operações de espera síncrona em ambientes de multithreading</td><td>Sincronização de threads</td><td>Melhor controle sobre a sincronização</td><td>Quando não há necessidade de sincronização de threads</td></tr><tr><td>const regex = /[a-zA-Z]/;</td><td>const regex = /\p{L}/u;</td><td>Para correspondência de caracteres com propriedades Unicode</td><td>Manipulação de strings</td><td>Aumenta a precisão na correspondência de padrões</td><td>Quando não há necessidade de correspondência de padrões complexos</td></tr><tr><td>const now = new Date();</td><td>const now = Temporal.Now.plainDateTimeISO();</td><td>Para manipulação moderna de datas e horas</td><td>Manipulação de datas e horas</td><td>API mais robusta e coerente</td><td>Quando não há necessidade de manipulação de datas e horas</td></tr><tr><td>switch (response.status) { case 200: handleSuccess(); break; case 404: handleNotFound(); break; default: handleError(); }</td><td>match (response.status) { when 200 -&gt; handleSuccess(), when 404 -&gt; handleNotFound(), when _ -&gt; handleError() }</td><td>Para lógica condicional complexa</td><td>Controle de fluxo</td><td>Sintaxe mais clara e menos propensa a erros</td><td>Quando não há necessidade de lógica condicional complexa</td></tr><tr><td>const name = person.name; const age = person.age;</td><td>const { name, age } = person;</td><td>Para desestruturar objetos</td><td>Desestruturação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de desestruturar objetos</td></tr></tbody>

<tbody><tr><td>const str = 'hello'; const chars = str.split('');</td><td>const chars = [...str];</td><td>Para dividir uma string em caracteres</td><td>Manipulação de strings</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de dividir strings em caracteres</td></tr><tr><td>const arr = [1, 2, 3]; const newArr = arr.map(x =&gt; x * 2);</td><td>const newArr = arr.flatMap(x =&gt; [x, x * 2]);</td><td>Para transformar e aplanar arrays</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de transformar e aplanar arrays</td></tr><tr><td>const obj = Object.assign({}, a, b);</td><td>const obj = { ...a, ...b };</td><td>Para mesclar objetos</td><td>Manipulação de objetos</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de mesclar objetos</td></tr><tr><td>const x = Math.max(a, b, c);</td><td>const x = Math.max(...[a, b, c]);</td><td>Para encontrar o valor máximo em um array</td><td>Manipulação de arrays</td><td>Sintaxe mais clara e eficiente</td><td>Quando não há necessidade de encontrar o valor máximo</td></tr></tbody></table>
</body>
</html>
